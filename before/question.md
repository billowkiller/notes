### 怎么理解面向对象编程 ###

面向对象编程注重的是：

1. 数据和其行为的打包封装
1. 程序的接口和实现的解耦

具体表现在编程中的用法就是：封装、继承、多态。

封装包括数据和行为。它隐藏了某一方法的具体执行步骤，取而代之的是通过消息传递机制传送消息给它。

继承是指，在某种情况下，一个类会有“子类”。子类比原本的类（称为父类）要更加具体化。子类会继承父类的属性和行为，并且也可包含它们自己的。

多态是指由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应。



### 线程、进程的区别 ###

线程是指进程内的一个执行单元,也是进程内的可调度实体.

与进程的区别

1. 地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间;
2. 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源
1. 线程是处理器调度的基本单位,但进程不是.
1. 二者均可并发执行.

进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于：

简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 线程的划分尺度小于进程，使得多线程程序的并发性高。 

另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 

线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。

进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 

线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.
### static在C和C++里各代表什么含义 ###

- 在**C语言**中，static可以用来修饰局部变量，全局变量以及函数
	1. 一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束。但是在这里要注意的是，虽然用static对局部变量进行修饰过后，其生命周期以及存储空间发生了变化，但是其作用域并没有改变，其仍然是一个局部变量，作用域仅限于该语句块。在用static修饰局部变量后，该变量只在初次运行时进行初始化工作，且只进行一次。
	2. static对全局变量进行修饰改变了其作用域的范围，由原来的整个工程可见变为本源文件可见。
	3. 用static修饰函数的话，情况与修饰全局变量大同小异，就是改变了函数的作用域。

- 在**C++中**static还具有其它功能，如果在C++中对类中的某个函数用static进行修饰，则表示该函数属于一个类而不是属于此类的任何特定对象；如果对类中的某个变量进行static修饰，表示该变量为类以及其所有的对象所有。它们在存储空间中都只存在一个副本。可以通过类和对象去调用。

### const在C/C++里什么意思 ###
[http://blog.csdn.net/Eric_Jo/article/details/4138548](http://blog.csdn.net/Eric_Jo/article/details/4138548)

### select/Poll模型 ### [http://blog.csdn.net/tianmohust/article/details/6677985](http://blog.csdn.net/tianmohust/article/details/6677985)

### std::move和std::forward ###

**左值和右值**概念的本质区别就是，左值是用户显示声明或分配内存的变量，能够直接用变量名访问，而右值主要是临时变量。

**std::move**是一个用于提示优化的函数，过去的c++98中，由于无法将作为右值的临时变量从左值当中区别出来，所以程序运行时有大量临时变量白白的创建后又立刻销毁，其中又尤其是返回字符串std::string的函数存在最大的浪费。因为并不是所有情况下，C++编译器都能进行返回值优化，所以在C++11中，编码者可以主动提示编译器，返回的对象是临时的，可以被挪作他用. 

	std::string fileContent = “oldContent”;
	s = std::move(readFileContent(fileName));
	
对象s在被赋值的时候，方法std::string::operator =(std::string&&)会被调用，符号&&告诉std::string类的编写者，传入的参数是一个临时对象，可以挪用其数据，于是std::string::operator =(std::string&&)的实现代码中，会置空形参，同时将原本保存在中形参中的数据移动到自身。

**std::forward**是用于模板编程中的.当一个临时变量传入形参为T&& t的模板函数时，T被推演为U，参数t所引用的临时变量因为开始能够被据名访问了，所以它变成了左值。这也就是std::forward存在的原因！当你以为实参是右值所以t也应该是右值时，它跟你开了个玩笑，它是左值！如果你要进一步调用的函数会根据左右值引用性来进行不同操作，那么你在将t传给其他函数时，应该先用std::forward恢复t的本来引用性，恢复的依据是模板参数T的推演结果。虽然t的右值引用行会退化，变成左值引用，但根据实参的左右引用性不同，T会被分别推演为U&和U.

使用std::forward的原因：由于声明为f(T&& t)的模板函数的形参t会失去右值引用性质，所以在将t传给更深层函数前，可能会需要回复t的正确引用行，当然，修改t的引用性办不到，但根据t返回另一个引用还是可以的。

### 随机算法 ###

- Las Vegas算法：这个算法总是能产生正确的结果，否则就不会返回结果。

- Monte Carlo算法：
总是会返回结果，但是结果不一定是正确的。但是出现不正确的答案的几率可以非常非常低，而且我们可以多次运行，每次做不同的随机选择，那么几率就更加低了。


随机算法的效率：比如一般算法的效率是O(n)，那么随机算法可以是O(1)，我们只选择一个实例来验证就可以了，比如前面的列子。当然我们也可以根据我们的需要选择多个实例m。那么效率就是O(m)。这个m要比n少很多。那么效率就高很多了。

### linux IPC ###

[http://www.cnblogs.com/itech/archive/2010/06/29/1767056.html](http://www.cnblogs.com/itech/archive/2010/06/29/1767056.html)

### futex ###

Mutex属于sleep-waiting类型的锁. 从 2.6.x 系列稳定版内核开始, Linux 的 mutex 都是 futex (Fast-Usermode-muTEX)锁.
futex（快速用户区互斥的简称）是一个在Linux上实现锁定和构建高级抽象锁如信号量和POSIX互斥的基本工具。它们第一次出现在内核开发的2.5.7版；其语义在2.5.40固定下来，然后在2.6.x系列稳定版内核中出现。

Futex 是由用户空间的一个对齐的整型变量和附在其上的内核空间等待队列构成. 多进程或多线程绝大多数情况下对位于用户空间的futex 的整型变量进行操作(汇编语言调用CPU提供的原子操作指令来增加或减少),而其它情况下,则需要通过代价较大的系统调用来对位于内核空间的等待队列进行 操作(如唤醒等待的进程/线程,或 将当前进程/线程放入等待队列). 除了多个线程同时竞争锁的少数情况外,基于 futex 的 lock 操作是不需要进行代价昂贵的系统调用操作的.

这种机制的核心思想是通过将大多数情况下非同时竞争 lock 的操作放到在用户空间来执行,而不是代价昂贵的内核系统调用方式来执行,从而提高了效率.

### 析构函数禁止抛出异常 ###

- 能够在异常传递的堆栈辗转开解的过程中，防止terminate被调用。
- 能帮助确保析构函数总能完成我们希望它做的所有事情。 

### Linux线程同步方式 ###
互斥量，条件变量，信号量

### 函数的调用过程 ###

系统函数：

程序运行的时候，本身是没有权利访问系统资源的，因为系统有限的资源可能被多个不同的应用程序同时访问，造成冲突。此外有些行为不借助操作系统是无法办到或者不能有效的办到。这就产生了系统调用。

x86体系下linux通过`0x80`号中断作为系统调用的入口，中断号是指中断向量表中的属性（还包括中断处理程序）。系统调用时软中断，指令是`int`，所以上述调用可以用`int 0x80`实现。不同的系统调用又有不同的系统调用号，对应于不同的系统调用函数，在上述指令执行之前，用户将系统调用号存入寄存器`eax`中，从而调用对应的系统函数，最后`eax`中存入系统调用的返回值。

具体过程如下：

1. 触发中断
2. 切换堆栈
3. 中断处理程序
4. 恢复堆栈，执行源程序

较新的CPU都提供了`sysenter/sysexit`指令（**快速系统调用指令**），专门用于系统调用的进入和退出，由于去掉了一些不必要的检查，它的速度比以前的`int`指令要快。因此在新的Linux系统中，大部分系统调用都采用了`sysenter`代替原来的`int 80`。除了一些比较慢的系统调用，如`clone`、`execve`等少数几个，因为对于这种系统调用，进入/退出内核空间所费的时钟周期，相对于其处理时间，几乎可以忽略不计。

考虑到和`glibc`的对接问题，现在`glibc`中不直接调用`int 80`或者`sysenter`。而是采用`vdso`（虚拟动态共享库）方式，在内核中生成一个页面，用于系统调用，叫做`vsyscall`，在`load_elf_binary`时，会将其映射到用户空间，`glibc`直接调用其中的函数。

对于某些系统调用如`gettimeoftheday`，系统创建了一个共享的内存页面，它是在内核态的，它的数据由内核来维护，但是，用户态也有权限访问这个内核页面，由此，不通过中断`gettimeofday`也就拿到了系统时间。

### 程序的执行过程 ###

首先在用户层面，bash进程会调用`fork()`系统调用创建一个新的进程，新的进程调用`execve()系`统调用执行指定的ELF，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。

系统通过文件开头的魔数判断是ELF文件后调用`load_elf_binary()`;

1. 检测ELF可执行文件格式的有效性
2. 寻找动态链接的“.interp”段，设置动态连接器路径
3. 根据ELF可执行文件的程序头表的描述，对ELF文件进行映射，比如代码、数据、只读数据。
4. 初始化ELF进程环境
5. 将系统调用的返回地址修改成ELF可执行文件的入口点，这个入口点取决于程序的连接方式，对于静态连接的ELF可执行文件，这个入口就是ELF文件的文件头中的`e_entry`所指向的地址；对于动态链接的ELF可执行文件，入口点就是动态链接器。

指令寄存器设置成程序的入口点，启动程序。

**系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。**

### 几种排序算法的思想和实现 ###

1. 选择排序

	**排序过程：**给定一个数值集合，循环遍历集合，每次遍历从集合中选择出最小或最大的放入集合的开头或结尾的位置，下次循环从剩余的元素集合中遍历找出最小的并如上操作，最后直至所有原集合元素都遍历完毕，排序结束。

	**分析总结：**选择排序时间复杂度比较高，达到了O（n^2），每次选择都要遍历一遍无序区间。选择排序对一类重要的元素序列具有较好的效率，就是元素规模很大，而排序码却比较小的序列。另外要说明的是选择排序是一种`不稳定的`排序方法。

2. 冒泡排序

	**排序过程：**冒泡排序的过程形如其名，就是依次比较相邻两个元素，优先级高（或大或小）的元素向后移动，直至到达序列末尾，无序区间就会相应地缩小。下一次再从无序区间进行冒泡操作，依此循环直至无序区间为1，排序结束。

	**分析总结：**冒泡排序的时间复杂度也比较高，达到O（n^2），每次遍历无序区间都将优先级高的元素移动到无序区间的末尾。冒泡排序是一种`稳定的`排序方式。

3. 插入排序

	**排序过程：**将前面的区间（初始区间为1，包含第一个元素）视作有序区间，然后将有序区间的后一元素插入到前面有序区间的适当位置。直至有有序区间扩展到原区间的大小，排序结束。

	**分析总结：**插入排序的时间复杂度达到O（n^2），排序的运行时间和待排序元素的原始排列顺序密切相关。插入排序是一种`稳定的`排序方法。

4. 快速排序

	**排序过程：**快速排序应该是应用最广泛的排序算法，它是采用了分治的思想（这种思想很重要）。其基本的思想就是任取待排序序列中的某个元素（元素的选取方式在一定程序上会影响实现过程和排序效率）作为标杆，将待排序序列划分为左右两个子序列，左侧元素小于标杆元素，右侧元素大于标杆元素，标杆元素则排在这两个子序列的中间，然后再对这两个子序列重复上述的方法，直至排序结束。

	**分析总结：**快速排序的时间复杂度为O（nlogn），是一种`不稳定`的排序算法。

5. 归并排序

	**排序过程：**归并排序的原理比较简单，也是基于分治思想的。它将待排序的元素序列分成两个长度相等的子序列，然后为每一个子序列排序，然后再将它们合并成一个序列。

	**分析总结：**归并排序最好、最差和平均时间复杂度都是O（nlogn），是一种`稳定的`排序算法。

6. 堆排序

	**排序过程：**堆排序的过程分为两个步骤，第一步是根据初始输入数据，建立一个初始堆；第二步是将堆顶元素与当前无序区间的最后一个元素进行交换，然后再从堆顶元素开始对堆进行调整。

	**分析总结：**堆排序的算法时间复杂度为O（nlogn），它是一种`不稳定`的排序算法。
